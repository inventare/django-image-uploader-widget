{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>The django-image-uploader-widget is a set of django widget and django-admin inline editor to handle better image uploads with a little bit modern user interface.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Support required and optional <code>ImageField</code>;</li> <li>Support for <code>ImageField</code> inside inlines of django-admin.</li> <li>Support preview modal;</li> <li>Support custom inline for django-admin multiple images uploader.</li> <li>Support reordering inside django-admin custom inline for multiple uploads.</li> <li>Support <code>ArrayField</code> for <code>PostgreSQL</code> database.</li> <li>Support upload by dropping file.</li> <li>Out of box HTMX support.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>Django 3.2+</li> </ul>"},{"location":"#getting-started_1","title":"Getting Started","text":"<p>To get started, install this plugin with the pip package manager:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>Version Information</p> <p>On the <code>1.0.0</code> release of this package we droped the support for <code>Django 3.2</code>, <code>Django 4.0</code> and <code>Django 4.1</code>. We, currently, maintain the support for <code>Django 4.2</code> (LTS), <code>Django 5.0</code> and <code>Django 5.1</code>. Then, if you are using <code>Django 3.2</code>, <code>4.0</code> or <code>4.1</code>, installs <code>0.7.1</code> version:</p> <pre><code>pip install django-image-uploader-widget==0.7.1\n</code></pre> <p>then, go to the <code>settings.py</code> file and add the <code>image_uploader_widget</code> to the installed apps:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'image_uploader_widget',\n    # ...\n]\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":""},{"location":"#with-admin","title":"With Admin","text":"<p>The <code>ImageUploaderWidget</code> is a class that implements a custom widget for single image uploader and can be used inside the <code>formfield_overrides</code> attribute inside the <code>ModelAdmin</code> class.</p> <p><pre><code># admin.py\nfrom django.contrib import admin\nfrom django.db import models\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import YourModel\n\n\n@admin.register(YourModel)\nclass YourModelAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.ImageField: {'widget': ImageUploaderWidget},\n    }\n</code></pre> See the documentation for more complex usage's.</p>"},{"location":"#with-modelform","title":"With ModelForm","text":"<p>The <code>ImageUploaderWidget</code> can be used inside the <code>widgets</code> Meta attribute of a <code>Form</code>/<code>ModelForm</code>:</p> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ExampleForm(forms.ModelForm):\n    class Meta:\n        widgets = {\n            'image': ImageUploaderWidget(),\n        }\n        fields = '__all__'\n</code></pre> <p>See the documentation for more complex usage's.</p>"},{"location":"#custom-inline-admin","title":"Custom Inline Admin","text":"<p>The <code>ImageUploaderInline</code> is implemented with the base of the <code>admin.StackedInline</code> to create an custom django-admin to work with multiple images upload using a model only to store the images:</p> <pre><code># models.py\n\nclass Product(models.Model):\n    # ...\n\nclass ProductImage(models.Model):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"images\",\n        on_delete=models.CASCADE\n    )\n    image = models.ImageField(\"image\")\n    # ...\n</code></pre> <pre><code># admin.py\nfrom django.contrib import admin\nfrom image_uploader_widget.admin import ImageUploaderInline\nfrom .models import Product, ProductImage\n\nclass ProductImageAdmin(ImageUploaderInline):\n    model = ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    inlines = [ProductImageAdmin]\n</code></pre> <p>See the documentation for more complex usage's.</p>"},{"location":"#array-field","title":"Array Field","text":"<p>The ArrayField support is made by a custom field, called <code>ImageListField</code>. Then, to use it, we need to change the field from default <code>ArrayField</code> to <code>ImageListField</code>. The reason for it is: the default <code>ArrayField</code> with <code>ImageField</code> not works and some part of the behaviour of the <code>ImageField</code> is implemented inside the <code>ImageListField</code>.</p> <pre><code># models.py\nfrom django.db import models\nfrom image_uploader_widget.postgres import ImageListField\n\nclass TestWithArrayField(models.Model):\n    images = ImageListField(blank=True, null=True, upload_to=\"admin_test\")\n\n    class Meta:\n        verbose_name = \"Test With Array Field\"\n</code></pre> <p>See the documentation for more complex usage's.</p>"},{"location":"#preview","title":"Preview","text":"<p>Bellow we have some preview screenshots for the widget and inline admin editor.</p>"},{"location":"#dark-theme","title":"Dark Theme","text":"<p>Preview of the widget in dark theme.</p> <p></p> <p></p>"},{"location":"#light-theme","title":"Light Theme","text":"<p>Preview of the widget in light theme.</p> <p></p> <p></p>"},{"location":"#behaviour","title":"Behaviour","text":"<p>Preview of the behaviour of the widget and inlines.</p> <p></p> <p></p>"},{"location":"array_field/01-tutorial/","title":"Getting Started","text":"<p>Version Information</p> <p>Introduced at the 0.5.0 version.</p> <p>Database Information</p> <p>Supported only on PostgreSQL Database's.</p> <p>The <code>widget</code> only supports <code>ImageField</code> and this is a limitation to upload only one image per widget. The <code>inline admin</code> support multiple images upload but it is only supported by the <code>django.contrib.admin</code> pages.</p> <p>Some comments, like the Discussion #97, Issue #146 and Issue #110 make some feature requests and the Issue #146 takes one proposition: uses the <code>ArrayField</code>. The <code>ArrayField</code> is a <code>PostgreSQL</code> specific field and support for storing multiple values into one field.</p>"},{"location":"array_field/01-tutorial/#experimental-for-now","title":"Experimental for Now?","text":"<p>Currently, we have added support, addaptating the <code>inline admin</code> feature to work widget-like and add support for the <code>ArrayField</code> to store images using the <code>storage</code> and save it path to an <code>ArrayField</code>. This is, really, a little experimental for now, and can contains some bugs. If your found one: open a Issue reporting.</p> <p>Attention Point</p> <p>See the attention point on the Prevent Raw Images Path Change page.</p>"},{"location":"array_field/01-tutorial/#usage","title":"Usage","text":"<p>Instead of <code>widget</code> or <code>inline admin</code> that we only set the <code>widget</code> and <code>inline admin</code> for the created model, in this part, we need to customize the model.</p> <pre><code>from django.db import models\nfrom image_uploader_widget.postgres import ImageListField\n\nclass TestWithArrayField(models.Model):\n    images = ImageListField(blank=True, null=True, upload_to=\"admin_test\")\n\n    class Meta:\n        verbose_name = \"Test With Array Field\"\n</code></pre> <p>This is really simple and is not needed to create more customizations. The widget and form is automatic created for the custom multiple images widget.</p>"},{"location":"array_field/02-prevent-raw-change/","title":"Prevent Raw Images Path Change","text":"<p>Like various other <code>multiple</code> instances or values support, we have an tiny problem at this component, for now: when we save a form with some \"unchanged\" values, i.e., with the current file path string instead of an uploaded file, this string is used to store in the database. Is planed, in the future, change this to use the original array values to confirm the sended values. But, for this first version, this is a issue that is not resolved.</p> <p>Example of how this works: navigate to widget change, and find for the hidden input with <code>-RAW</code> name. Change the value to another and saves. The wrong value is correctly saved.</p> <p></p>"},{"location":"array_field/02-prevent-raw-change/#how-to-prevent-this-behaviour","title":"How to prevent this behaviour?","text":"<p>One of the way to prevent this behaviour is create a custom <code>ModelForm</code> and raises a <code>ValidationError</code> for string values that is not present on the original value. See a example:</p> <pre><code>from django import forms\nfrom django.core.exceptions import ValidationError\n\n\nclass TestWithArrayFieldForm(forms.ModelForm):\n    old_values = []\n\n    def map_is_valid_images(self, value):\n        if not isinstance(value, str):\n            return False\n        return value not in self.old_values\n\n    def clean(self):\n        data = super().clean()\n\n        self.old_values = []\n        if self.instance is not None:\n            self.old_values = self.instance.images\n\n        has_changed = any(list(map(self.map_is_valid_images, data.get('images'))))\n        if has_changed:\n            raise ValidationError('One of the non-changed value is corrupted.')\n\n        return data\n\n    class Meta:\n        model = TestWithArrayField\n        fields = \"__all__\"\n</code></pre>"},{"location":"array_field/03-htmx/","title":"Out of Box HTMX Support","text":"<p>Version Information</p> <p>Introduced at the 0.6.0 version.</p> <p>The array field, now, has out of box support for HTMX. see docs here.</p>"},{"location":"array_field/04-force-color-scheme/","title":"Force dark or light color scheme","text":"<p>On the ADR 0006 we discuted a way to force color scheme (<code>dark</code> or <code>light</code>) to ensure widget color scheme outside of <code>django-admin</code>. The two cases bellow is tested using UI regression tests. This is the same way that we implemented on default widget and this is documented here.</p>"},{"location":"array_field/04-force-color-scheme/#light-theme","title":"Light theme","text":"<p>To enforce light widget, use <code>.iuw-light</code> class:</p> <pre><code>&lt;div class=\"iuw-light\"&gt;\n  {{ form }}\n&lt;/div&gt;\n</code></pre>"},{"location":"array_field/04-force-color-scheme/#dark-theme","title":"Dark theme","text":"<p>To enforce dark widget, use <code>.iuw-dark</code> class:</p> <pre><code>&lt;div class=\"iuw-dark\"&gt;\n  {{ form }}\n&lt;/div&gt;\n</code></pre>"},{"location":"array_field/05-max-images/","title":"Max number of images","text":"<p>Version Information</p> <p>Introduced at the 1.1.0 version.</p> <p>Database Information</p> <p>Supported only on PostgreSQL Database's.</p> <p>We introduced a <code>kwarg</code> called <code>max_images</code> on <code>ImageListField</code> field to limit the number of images that user can choose by picker. The default value is <code>1000</code> (only because this value are, previous, hardcoded value on the html template). The usage is:</p> <pre><code>from django.db import models\nfrom image_uploader_widget.postgres import ImageListField\n\nclass TestWithArrayField(models.Model):\n    images = ImageListField(blank=True, null=True, max_images=2, upload_to=\"admin_test\")\n\n    class Meta:\n        verbose_name = \"Test With Array Field\"\n</code></pre> <p>Validation</p> <p>The limit, for now, is only on front-end widget. If you want to validate in server-side, do it by yourself for now.</p>"},{"location":"htmx/01-widget/","title":"Out of box HTMX Support for Widget","text":"<p>Version Information</p> <p>Introduced at the 0.6.0 version.</p> <p>The HTMX is, now, out of box supported, for widget and array field widget. Even though it has support out of the box, some precautions need to be taken. The media (scripts and styles of the widget) needs to be loaded in the parent document:</p>"},{"location":"htmx/01-widget/#behaviour","title":"Behaviour","text":"<p>On the version <code>0.6.0</code> the JavaScript of the widget was rewrited using event Event bubbling and the render part is moved to template system to support the widget behaviour without initialization needed.</p>"},{"location":"htmx/01-widget/#usage-example","title":"Usage Example","text":"<p>This usage example is taken form <code>tests</code> application that is used to run our e2e test cases. The parent view and template is created using:</p> <pre><code># views.py\ndef render_parent(request):\n    form = TestRequiredForm()\n    form2 = TestWithArrayFieldForm()\n    context = {\n        \"media\": form.media + form2.media,\n    }\n    template = \"test_htmx.html\"\n    return render(request, template, context=context)\n</code></pre> <pre><code>&lt;!-- test_htmx.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;HTMX&lt;/title&gt;\n  {{ media }}\n&lt;/head&gt;\n&lt;body  hx-headers='{\"X-CSRFToken\": \"{{ csrf_token }}\"}'&gt;\n\n  &lt;button\n    hx-get=\"/test-htmx-image-widget/required/\"\n    hx-target=\"this\"\n    hx-swap=\"outerHTML\"\n    hx-trigger=\"click\"\n    type=\"button\"\n    class=\"btn-load\"\n  &gt;\n    Load\n  &lt;/button&gt;\n\n  &lt;script src=\"https://unpkg.com/htmx.org@1.9.12\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The widget view and template is created using:</p> <pre><code># views.py\ndef render_widget_required(request, pk=None):\n    instance = TestRequired.objects.get(pk=pk) if pk else None\n    if request.method == \"POST\":\n        form = TestRequiredForm(\n            instance=instance, data=request.POST, files=request.FILES\n        )\n        if form.is_valid():\n            form.save()\n            instance = form.instance\n            form = TestRequiredForm(instance=instance)\n            add_message(request, SUCCESS, \"Saved\")\n    else:\n        form = TestRequiredForm(instance=instance)\n\n    context = {\n        \"form\": form,\n        \"instance\": instance,\n        \"post_url\": \"test-htmx-image-widget/required\",\n    }\n    template = \"test_htmx_widget.html\"\n    return render(request, template, context=context)\n</code></pre> <pre><code>&lt;!-- test_htmx_widget.html --&gt;\n&lt;form\n  hx-post=\"/test-htmx-image-widget/required/{% if instance %}{{ instance.pk }}/{% endif %}\"\n  hx-target=\"this\"\n  hx-swap=\"outerHTML\"\n  enctype=\"multipart/form-data\"\n  id=\"my-widget-form\"\n&gt;\n  {% if messages %}\n    &lt;ul class=\"messagelist\"&gt;\n      {% for message in messages %}\n        &lt;li class=\"{{ message.tags }}\"&gt;{{ message }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n\n  {{ form }}\n\n  &lt;button class=\"btn-submit\" type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"htmx/02-array_field/","title":"Out of box HTMX Support for Array Field","text":"<p>Version Information</p> <p>Introduced at the 0.6.0 version.</p>"},{"location":"htmx/02-array_field/#behaviour","title":"Behaviour","text":"<p>The behaviour for the out of box HTMX support for Array Field is a little bit different of the widget. The array field uses the base of inline admin to render the widget and the drag and drop support request initialization. Then to add out of box support, we decided to handle the initialization inside the <code>htmx:afterSwap</code> event:</p> <pre><code>// image-uploader-inline.js\n//\n// ...\n//\ndocument.addEventListener('DOMContentLoaded', function() {\n  initialize();\n});\ndocument.addEventListener('htmx:afterSwap', function(ev) {\n  initialize(ev.target);\n})\n</code></pre>"},{"location":"htmx/02-array_field/#usage-example","title":"Usage example","text":"<p>The usage example is the same of the widget. The parent view and template is created using:</p> <pre><code># views.py\ndef render_parent(request):\n    form = TestRequiredForm()\n    form2 = TestWithArrayFieldForm()\n    context = {\n        \"media\": form.media + form2.media,\n    }\n    template = \"test_htmx.html\"\n    return render(request, template, context=context)\n</code></pre> <pre><code>&lt;!-- test_htmx.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;HTMX&lt;/title&gt;\n  {{ media }}\n&lt;/head&gt;\n&lt;body  hx-headers='{\"X-CSRFToken\": \"{{ csrf_token }}\"}'&gt;\n\n  &lt;button\n    hx-get=\"/test-htmx-image-widget/array_field/\"\n    hx-target=\"this\"\n    hx-swap=\"outerHTML\"\n    hx-trigger=\"click\"\n    type=\"button\"\n    class=\"btn-load\"\n  &gt;\n    Load\n  &lt;/button&gt;\n\n  &lt;script src=\"https://unpkg.com/htmx.org@1.9.12\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The widget view and template is created using:</p> <pre><code># views.py\ndef render_array_field_required(request, pk=None):\n    instance = TestWithArrayField.objects.get(pk=pk) if pk else None\n    if request.method == \"POST\":\n        form = TestWithArrayFieldForm(\n            instance=instance, data=request.POST, files=request.FILES\n        )\n        if form.is_valid():\n            form.save()\n            instance = form.instance\n            form = TestWithArrayFieldForm(instance=instance)\n            add_message(request, SUCCESS, \"Saved\")\n    else:\n        form = TestWithArrayFieldForm(instance=instance)\n\n    context = {\n        \"form\": form,\n        \"instance\": instance,\n        \"post_url\": \"test-htmx-image-widget/array_field\",\n    }\n    template = \"test_htmx_widget.html\"\n    return render(request, template, context=context)\n</code></pre> <pre><code>&lt;!-- test_htmx_widget.html --&gt;\n&lt;form\n  hx-post=\"/test-htmx-image-widget/array_field/{% if instance %}{{ instance.pk }}/{% endif %}\"\n  hx-target=\"this\"\n  hx-swap=\"outerHTML\"\n  enctype=\"multipart/form-data\"\n  id=\"my-widget-form\"\n&gt;\n  {% if messages %}\n    &lt;ul class=\"messagelist\"&gt;\n      {% for message in messages %}\n        &lt;li class=\"{{ message.tags }}\"&gt;{{ message }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n\n  {{ form }}\n\n  &lt;button class=\"btn-submit\" type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"inline_admin/01-tutorial/","title":"Tutorial","text":"<p>First, we need of some context: the image uploader inline is an inline admin editor (like the StackedInline or the TabularInline of the original django). This inline editor is created to make an multiple images manager widget using an model with an image field.</p>"},{"location":"inline_admin/01-tutorial/#creating-a-django-project","title":"Creating a django project","text":"<p>First, create a project folder. Here we call it as <code>my-ecommerce</code>:</p> <pre><code>mkdir my-ecommerce\ncd my-ecommerce\n</code></pre> <p>And, now, create a django project in this folder:</p> <pre><code>django-admin startproject core .\n</code></pre> <p>And, then, we have the folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - manage.py\n</code></pre> <p>Create our django application by running the command:</p> <pre><code>python manage.py startapp ecommerce\n</code></pre> <p>And, now, we have a new, and more complex, folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - ecommerce\n    | - migrations\n      | - __init__.py\n    | - admin.py\n    | - apps.py\n    | - __init__.py\n    | - models.py\n    | - tests.py\n    | - views.py\n  | - manage.py\n</code></pre>"},{"location":"inline_admin/01-tutorial/#installing-the-widget","title":"Installing the widget","text":"<p>To install the widget, is possible to use the same instructions of the Getting started, and the first step is to install the package with pip:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>Version Information</p> <p>On the <code>1.0.0</code> release of this package we droped the support for <code>Django 3.2</code>, <code>Django 4.0</code> and <code>Django 4.1</code>. We, currently, maintain the support for <code>Django 4.2</code> (LTS), <code>Django 5.0</code> and <code>Django 5.1</code>. Then, if you are using <code>Django 3.2</code>, <code>4.0</code> or <code>4.1</code>, installs <code>0.7.1</code> version:</p> <pre><code>pip install django-image-uploader-widget==0.7.1\n</code></pre> <p>then, add it to the <code>INSTALLED_APPS</code> on the <code>settings.py</code>, in the case of this example: <code>core/settings.py</code> file. To understand better the Applications, see the django documentation: Applications.</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre>"},{"location":"inline_admin/01-tutorial/#warning","title":"Warning","text":"<p>Observation: note that the application name to be added on the <code>INSTALLED_APPS</code> are not equals to the pip package name / install name.</p>"},{"location":"inline_admin/01-tutorial/#using-the-inline-editor","title":"Using the inline editor","text":"<p>This inline editor is created to be used directly with the django-admin interface. To show how to use it, go to create two basic models inside the <code>ecommerce</code> app (Add your app, <code>ecommerce</code> in my case, at <code>INSTALLED_APPS</code> is recommended):</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n\nclass ProductImage(models.Model):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"images\",\n        on_delete=models.CASCADE\n    )\n    image = models.ImageField(\"image\")\n\n    def __str__(self):\n        return str(self.image)\n\n    class Meta:\n        verbose_name = 'Product Image'\n        verbose_name_plural = 'Product Images'\n</code></pre> <p>Now, inside our admin, we can create an primary ModelAdmin for the product:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    pass\n</code></pre> <p>And, now, we can define our inline widget:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\nfrom image_uploader_widget.admin import ImageUploaderInline\n\nclass ProductImageAdmin(ImageUploaderInline):\n    model = ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    inlines = [ProductImageAdmin]\n</code></pre> <p>And we got the inline editor working as well:</p> <p></p>"},{"location":"inline_admin/02-ordered/","title":"Ordered Images Admin","text":"<p>Version Information</p> <p>Introduced at the 0.4.1 version.</p> <p>The first thing needed to understand the ordered version of the <code>ImageUploaderInline</code> is read the inline tutorial. This page has a documentation of how to extend the <code>ImageUploaderInline</code> with order field to allow to reorder, by clicking and dragging, the images inside the inline.</p> <p></p>"},{"location":"inline_admin/02-ordered/#adding-order-field-to-model","title":"Adding Order Field to Model","text":"<p>Add a <code>PositiveIntegerField</code> to the model to store the order of the images inside the admin.</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n\nclass ProductImage(models.Model):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"images\",\n        on_delete=models.CASCADE\n    )\n    image = models.ImageField(\"image\")\n    order = models.PositiveIntegerField('Order', default=1)\n\n    def __str__(self):\n        return str(self.image)\n\n    class Meta:\n        verbose_name = 'Product Image'\n        verbose_name_plural = 'Product Images'\n</code></pre>"},{"location":"inline_admin/02-ordered/#change-inline-to-orderedimageuploaderinline","title":"Change inline to OrderedImageUploaderInline","text":"<p>Inside the <code>admin.py</code>, change the inline from <code>ImageUploaderInline</code> to <code>OrderedImageUploaderInline</code> and setup some configs:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\nfrom image_uploader_widget.admin import ImageUploaderInline\n\nclass ProductImageAdmin(OrderedImageUploaderInline):\n    model = ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    inlines = [ProductImageAdmin]\n</code></pre>"},{"location":"inline_admin/02-ordered/#attributes","title":"Attributes","text":"Attribute Type Default Value Description order_field <code>str</code> <code>\"order\"</code> The name of field that represents the order of images. template <code>str</code> <code>\"admin/edit_inline/ordered_image_uploader.html\"</code> The template path to render the widget. <p>All the attributes from the <code>ImageUploaderInline</code> are present too. For example, is possible to change the name of the used <code>order_field</code> by adding it's attribute to the <code>OrderedImageUploaderInline</code>:</p> <pre><code>from image_uploader_widget.admin import ImageUploaderInline\n\nclass MyInlineAdminAdmin(OrderedImageUploaderInline):\n    model = MyModel\n    order_field = \"my_custom_field\"\n</code></pre>"},{"location":"inline_admin/02-ordered/#mobile-touch-support","title":"Mobile Touch Support","text":"<p>Version Information</p> <p>Introduced at the 0.6.0 version.</p> <p>The original behaviour for <code>OrderedImageUploaderInline</code> is manual created and don't support mobile touch events. On the version <code>0.6.0</code> the sorting uses the Sortable and, then, the mobile touch events are supported.</p>"},{"location":"inline_admin/03-accept/","title":"Change Accept Formats","text":"<p>Like as the Widget <code>accept</code> attribute, see reference here, we have an way to customize the accept of the <code>ImageUploaderInline</code>. To customize it, use the <code>accept</code> property inside an class that inherits from <code>ImageUploaderInline</code>, like:</p> <pre><code>from image_uploader_widget.admin import ImageUploaderInline\nfrom . import models\n\nclass InlineEditor(ImageUploaderInline):\n    model = models.InlineItem\n    accept = \"image/jpeg\"\n</code></pre>"},{"location":"inline_admin/04-custom-text-and-icons/","title":"Custom Text and Icons","text":"<p>To customize the text and the icons of the inline editor is a little bit faster too. We can set some variables on the <code>InlineAdmin</code> of your model, like this:</p> <pre><code>class CustomInlineEditor(ImageUploaderInline):\n    model = models.CustomInlineItem\n    add_image_text = \"add_image_text\"\n    drop_text = \"drop_text\"\n    empty_text = \"empty_text\"\n\n    def get_empty_icon(self):\n        return render(...)\n\n    def get_add_icon(self):\n        return render(...)\n\n    def get_drop_icon(self):\n        return render(...)\n\n@admin.register(models.CustomInline)\nclass CustomInlineAdmin(admin.ModelAdmin):\n    inlines = [CustomInlineEditor]\n</code></pre>"},{"location":"inline_admin/05-custom-colors/","title":"Custom Colors","text":"<p>To customize the image uploader inline colors you can use your own css file to override the css variables defined by the <code>image-uploader-inline.css</code>. See an example:</p> <pre><code>body {\n    --iuw-background: #FFF;\n    --iuw-border-color: #CCC;\n    --iuw-color: #333;\n    --iuw-placeholder-text-color: #AAA;\n    --iuw-placeholder-destak-color: #417690;\n    --iuw-dropzone-background: rgba(255, 255, 255, 0.8);\n    --iuw-image-preview-border: #BFBFBF;\n    --iuw-image-preview-shadow: rgba(0, 0, 0, 0.3);\n    --iuw-add-image-background: #EFEFEF;\n    --iuw-add-image-color: #AAA;\n}\n</code></pre> <p>Observation: To see better the variables name, check the css file at the GitHub repository: here.</p>"},{"location":"widget/01-resumed/","title":"Getting Started","text":"<p>If you want to read a more complete description of how to use this widget, see the Tutorial. But, if you is an advanced user, only install the package:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>Version Information</p> <p>On the <code>1.0.0</code> release of this package we droped the support for <code>Django 3.2</code>, <code>Django 4.0</code> and <code>Django 4.1</code>. We, currently, maintain the support for <code>Django 4.2</code> (LTS), <code>Django 5.0</code> and <code>Django 5.1</code>. Then, if you are using <code>Django 3.2</code>, <code>4.0</code> or <code>4.1</code>, installs <code>0.7.1</code> version:</p> <pre><code>pip install django-image-uploader-widget==0.7.1\n</code></pre> <p>and add the <code>image_uploader_widget</code> to the <code>INSTALLED_APPS</code> in the <code>settings.py</code>:</p> <pre><code># ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre> <p>And go to use it with your forms:</p> <pre><code>from django.forms import ModelForm\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n        widgets = {\n            'image': ImageUploaderWidget()\n        }\n</code></pre> <p></p>"},{"location":"widget/02-tutorial/","title":"Full Usage Tutorial","text":"<p>First, we need of some context: the image uploader widget is a widget to handle image uploading with a beautiful interface with click to select file and a drop file behaviour handler. It is used with django forms.</p> <p>This is a more long and for newbies tutorial of how to use this widget. If you is an advanced user, see the Resumed version.</p> <p>To write this tutorial of this documentation we go to create an empty django project, then if you don't want to see this part, skip to using the widget section. Another information is: we're assuming you already know the basics of django and already have it installed in your machine.</p>"},{"location":"widget/02-tutorial/#creating-a-django-project","title":"Creating a django project","text":"<p>First, create a project folder. Here we call it as <code>my-ecommerce</code>:</p> <pre><code>mkdir my-ecommerce\ncd my-ecommerce\n</code></pre> <p>And, now, create a django project in this folder:</p> <pre><code>django-admin startproject core .\n</code></pre> <p>And, then, we have the folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - manage.py\n</code></pre> <p>Create our django application by running the command:</p> <pre><code>python manage.py startapp ecommerce\n</code></pre> <p>And, now, we have a new, and more complex, folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - ecommerce\n    | - migrations\n      | - __init__.py\n    | - admin.py\n    | - apps.py\n    | - __init__.py\n    | - models.py\n    | - tests.py\n    | - views.py\n  | - manage.py\n</code></pre>"},{"location":"widget/02-tutorial/#installing-the-widget","title":"Installing the widget","text":"<p>To install the widget, is possible to use the same instructions of the Getting started, and the first step is to install the package with pip:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>Version Information</p> <p>On the <code>1.0.0</code> release of this package we droped the support for <code>Django 3.2</code>, <code>Django 4.0</code> and <code>Django 4.1</code>. We, currently, maintain the support for <code>Django 4.2</code> (LTS), <code>Django 5.0</code> and <code>Django 5.1</code>. Then, if you are using <code>Django 3.2</code>, <code>4.0</code> or <code>4.1</code>, installs <code>0.7.1</code> version:</p> <pre><code>pip install django-image-uploader-widget==0.7.1\n</code></pre> <p>then, add it to the <code>INSTALLED_APPS</code> on the <code>settings.py</code>, in the case of this example: <code>core/settings.py</code> file. To understand better the Applications, see the django documentation: Applications.</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre> <p>Observation</p> <p>Note that the application name to be added on the <code>INSTALLED_APPS</code> are not equals to the pip package name / install name.</p>"},{"location":"widget/02-tutorial/#using-the-widget","title":"Using the widget","text":"<p>We have two basic modes to use this widget:</p> <ol> <li> <p>creating a ORM <code>Model</code> and using an <code>ModelForm</code> to it setting the widget.</p> </li> <li> <p>creating an custom <code>Form</code> with any other behaviour.</p> </li> </ol>"},{"location":"widget/02-tutorial/#with-modelform","title":"With ModelForm","text":"<p>First, go to our ecommerce app models <code>ecommerce/models.py</code> and create a basic django model with an <code>ImageField</code>:</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    image = models.ImageField()\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n</code></pre> <p>Now, we go to create our <code>ModelForm</code>. Create a empty file on <code>ecommerce/forms.py</code> to store our django forms. And create our own <code>ProductForm</code>:</p> <pre><code># ecommerce/forms.py\nfrom django.forms import ModelForm\nfrom ecommerce.models import Product\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n</code></pre> <p>And, here, we can declare the widget that our <code>image</code> field uses:</p> <pre><code># ecommerce/forms.py\nfrom django.forms import ModelForm\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n        widgets = {\n            'image': ImageUploaderWidget()\n        }\n</code></pre>"},{"location":"widget/02-tutorial/#creating-and-applying-migrations","title":"Creating and applying migrations","text":"<p>Our Model, declared in the above section, needs to be inserted on our database using the migrations. To create our migrations, we need to add our <code>ecommerce</code> app to <code>INSTALLED_APPS</code> on the <code>settings.py</code>:</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n    'ecommerce',\n]\n\n# ...\n</code></pre> <p>Now, we go to create the migrations using the command:</p> <pre><code>python manage.py makemigrations\n</code></pre> <p>If you found an <code>ecommerce.Product.image: (fields.E210) Cannot use ImageField because Pillow is not installed.</code> error, just run an:</p> <pre><code>pip install Pillow\n</code></pre> <p>and re-run the makemigrations command. Now, we go to apply the migrations with:</p> <pre><code>python manage.py migrate\n</code></pre> <p>And, now, we can run the development server to see our next steps coding:</p> <pre><code>python manage.py runserver\n</code></pre>"},{"location":"widget/02-tutorial/#see-it-in-the-action","title":"See it in the action","text":"<p>To see the widget in action, just go to the ecommerce app and create, in the <code>views.py</code>, an view that renders an form:</p> <pre><code># ecommerce/views.py\nfrom django.shortcuts import render\nfrom ecommerce.forms import ProductForm\n\ndef test_widget(request):\n    context = { 'form': ProductForm() }\n    return render(request, 'test_widget.html', context)\n</code></pre> <p>Now, we can create an <code>templates</code> folder in the <code>ecommerce</code> application and inside it we need to create a <code>test_widget.html</code>:</p> <pre><code>&lt;!-- ecommerce/templates/test_widget.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    {{ form.media }}\n&lt;/head&gt;\n&lt;body&gt;\n\n    {{ form.as_p }}\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>And register this view in the <code>core/urls.py</code>:</p> <pre><code># core/urls.py\nfrom django.contrib import admin\nfrom django.urls import path\nfrom ecommerce.views import test_widget\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('test_widget/', test_widget),\n]\n</code></pre> <p>And go to the browser in <code>http://localhost:8000/test_widget/</code> and see the result:</p> <p></p>"},{"location":"widget/02-tutorial/#with-form-and-custom-behaviour","title":"With Form and custom behaviour","text":"<p>It's very like the above item and we need only to change some things in the <code>forms.py</code>:</p> <pre><code>from django import forms\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(forms.Form):\n    image = forms.ImageField(widget=ImageUploaderWidget())\n\n    class Meta:\n        fields = ['image']\n</code></pre> <p>And we not need to change nothing more. It works.</p>"},{"location":"widget/02-tutorial/#comments-about-using-with-django-admin","title":"Comments about using with django-admin","text":"<p>The use with django-admin is very like it: we only needs to create <code>ModelForm</code> for our models and in the <code>ModelAdmin</code> (django documentation) we set our form (here is an example).</p>"},{"location":"widget/04-accept/","title":"Change Accept Formats","text":"<p>When working with HTML <code>&lt;input /&gt;</code> element, we have an <code>accept=\"\"</code> attribute that works defining the visible file types into the file picker dialog. An better, and complete, description of this attribute can be found at MDN.</p> <p>To define this attribute, with the <code>ImageUploaderWidget</code>, we can set the <code>attrs</code> property when instantiate the <code>ImageUploaderWidget</code>, like:</p> <pre><code>from django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import CustomWidget\n\nclass TestForm(forms.ModelForm):\n    class Meta:\n        widgets = {\n            'image': ImageUploaderWidget(attrs={ 'accept': 'image/png' }),\n        }\n        fields = '__all__'\n</code></pre>"},{"location":"widget/05-htmx/","title":"Out of Box HTMX Support","text":"<p>Version Information</p> <p>Introduced at the 0.6.0 version.</p> <p>The widget, now, has out of box support for HTMX. see docs here.</p>"},{"location":"widget/06-custom-text-and-icons/","title":"Custom Text and Icons","text":"<p>To customize the image uploader widget, you can set some variables (this feature is based on the issue #77). In this page we talk about how to, easy, change the texts and icons on that lib.</p> <p>For the widget, to customize the icon and the text we need to set some variables in the <code>ImageUploaderWidget</code> constructor, like it:</p> <pre><code># ...\nclass TestCustomForm(forms.ModelForm):\n    class Meta:\n        model = CustomWidget\n        widgets = {\n            'image': ImageUploaderWidget(\n                drop_icon=\"&lt;svg ...&gt;&lt;/svg&gt;\",\n                drop_text=\"Custom Drop Text\",\n                empty_icon=\"&lt;svg ...&gt;&lt;/svg&gt;\",\n                empty_text=\"Custom Empty Marker Text\",\n            ),\n        }\n        fields = '__all__'\n</code></pre> <p>In this example, we set all four properties (<code>drop_icon</code>, <code>drop_text</code>, <code>empty_icon</code> and <code>empty_text</code>) for the widget. In the icons is possible to use the <code>django.shortcuts.render</code> (REF) to renderize the icon from an HTML template.</p> <p>Another way for customize it is create an new widget class based on that and use it for your forms:</p> <pre><code>class MyCustomWidget(ImageUploaderWidget):\n    drop_text = \"\"\n    empty_text = \"\"\n\n    def get_empty_icon(self):\n        return render(...)\n\n    def get_drop_icon(self):\n        return render(...)\n\nclass TestCustomForm(forms.ModelForm):\n    class Meta:\n        model = CustomWidget\n        widgets = {\n            'image': MyCustomWidget()\n        }\n        fields = '__all__'\n</code></pre>"},{"location":"widget/07-force-color-scheme/","title":"Force dark or light color scheme","text":"<p>On the ADR 0006 we discuted a way to force color scheme (<code>dark</code> or <code>light</code>) to ensure widget color scheme outside of <code>django-admin</code>. The two cases bellow is tested using UI regression tests.</p>"},{"location":"widget/07-force-color-scheme/#light-theme","title":"Light theme","text":"<p>To enforce light widget, use <code>.iuw-light</code> class:</p> <pre><code>&lt;div class=\"iuw-light\"&gt;\n  {{ form }}\n&lt;/div&gt;\n</code></pre>"},{"location":"widget/07-force-color-scheme/#dark-theme","title":"Dark theme","text":"<p>To enforce dark widget, use <code>.iuw-dark</code> class:</p> <pre><code>&lt;div class=\"iuw-dark\"&gt;\n  {{ form }}\n&lt;/div&gt;\n</code></pre>"},{"location":"widget/08-custom-colors/","title":"Custom Colors","text":"<p>To customize the image uploader widget colors you can use your own css file to override the css variables defined by the <code>image-uploader-widget.css</code>:</p> <pre><code>body {\n    --iuw-background: #FFF;\n    --iuw-border-color: #CCC;\n    --iuw-color: #333;\n    --iuw-placeholder-text-color: #AAA;\n    --iuw-placeholder-destak-color: #417690;\n    --iuw-dropzone-background: rgba(255, 255, 255, 0.8);\n    --iuw-image-preview-border: #BFBFBF;\n    --iuw-image-preview-shadow: rgba(0, 0, 0, 0.3);\n    --iuw-add-image-background: #EFEFEF;\n    --iuw-add-image-color: #AAA;\n}\n</code></pre> <p>Observation: To see better the variables name, check the css file at the GitHub repository: here.</p>"},{"location":"widget/specific-cases/01-crispy-forms/","title":"Usage with django-crispy-forms","text":"<p>The <code>django-crispy-forms</code> not support, out of box, custom widgets and this is a problem of <code>django-crispy-forms</code>. Howere, inspired by #203 issue, we decided to learn about the <code>crispy</code> package and document how to made custom widget work with it.</p>"},{"location":"widget/specific-cases/01-crispy-forms/#formhelper","title":"FormHelper","text":"<p>The easy way to make a custom widget to work with <code>django-crispy-forms</code> is to define a <code>FormHelper</code> inside the <code>Form</code> instance:</p> <pre><code>from crispy_forms.helper import FormHelper\nfrom crispy_forms.layout import Layout, Div\nfrom django import forms\n\nclass TestCrispyRequiredForm(forms.ModelForm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.helper = FormHelper(self)\n        self.helper.layout = Layout(\n            Row(\n                Column(\n                    Div('image', template='image_uploader_widget/widget/image_uploader_widget.html'),\n                    css_class='form-group col-md-6 mb-0',\n                ),\n                css_class='form-row'\n            ),\n        )\n\n    class Meta:\n        model = TestRequired\n        widgets = {\n            \"image\": ImageUploaderWidget(),\n        }\n        fields = \"__all__\"\n</code></pre> <p>The definition of the <code>ImageUploaderWidget()</code> inside the <code>widgets</code> meta property is important to render the correct media styles:</p> <pre><code>{% load crispy_forms_tags %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  {{ form.media }}\n&lt;/head&gt;\n&lt;body&gt;\n\n  {% crispy form %}\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>And, for the end of this article, the generated HTML should appear like this:</p> <pre><code>&lt;div class=\"form-row form-row\"&gt;\n    &lt;div class=\"form-group col-md-6 mb-0\"&gt;\n        &lt;!-- THE WIDGET IS RENDERED HERE! ---&gt;\n        &lt;div class=\"iuw-root  empty\" ...&gt;...&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>The JavaScript and Styles is inserted by <code>{{ form.media }}</code> and the <code>ImageUploaderWidget</code> should works.</p>"},{"location":"widget/specific-cases/03-multiple-instances-of-same-form/","title":"Multiple Instances of Same Form","text":"<p>On the issue #112, @tlcaputi asked about using the <code>django-image-uploader-widget</code> with several forms. The answer for this issue, motivated this documentation article.</p> <p>The basic idea for this article is: we have an <code>view</code> with multiples instances of the same <code>ModelForm</code> with one (or more) <code>django-image-uploader-widget</code>. For example, we have a <code>Event</code> model, a <code>EventEditForm</code> model form, a <code>page</code> view and a <code>page.html</code> template:</p> <pre><code># models.py\nfrom django.db import models\n\nclass Event(models.Model):\n    event_title = models.CharField(max_length=200)\n    headshot = models.ImageField(upload_to='profile_pictures/', default='profile_pictures/default.jpg')\n</code></pre> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import Event\n\nclass EventEditForm(forms.ModelForm):\n    class Meta:\n        model = Event\n        widgets = {\n            'headshot': ImageUploaderWidget(),\n        }\n        fields = [\n            'event_title',\n            'headshot'\n        ]\n</code></pre> <pre><code># views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .models import Event\nfrom .forms import EventEditForm\n\ndef page(request):\n    if request.method == \"GET\":\n        events = Event.objects.all()\n        events_with_forms = []\n        for event in events:\n            events_with_forms.append({\n                'event': event,\n                'form': EventEditForm(instance=event),\n            })\n        return render(request, \"page.html\", {\n            'events_with_form': events_with_forms,\n            'new_event_form': EventEditForm(),\n        })\n    if request.method == \"POST\":\n        event_id = request.POST.get('event_id')\n        if not event_id:\n            form = EventEditForm(request.POST, request.FILES)\n            if form.is_valid():\n                form.save()\n                return redirect('home')\n\n        event = get_object_or_404(Event, pk=event_id)\n        form = EventEditForm(request.POST, request.FILES, instance=event)\n        if form.is_valid():\n            form.save()\n            return redirect('home')\n</code></pre> <pre><code>&lt;!-- templates/page.html --&gt;\n{% load crispy_forms_filters %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    {{new_event_form.media}}\n&lt;/head&gt;\n&lt;body&gt;\n\n    {% for event in events_with_form %}\n        &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n            {% csrf_token %}\n            &lt;input type=\"hidden\" name=\"event_id\" value=\"{{ event.event.id }}\"&gt;\n            {{ event.form|crispy }}\n            &lt;button type=\"submit\"&gt;Update&lt;/button&gt;\n        &lt;/form&gt;\n    {% endfor %}\n\n    &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n        {% csrf_token %}\n        {{ new_event_form|crispy }}\n        &lt;button type=\"submit\"&gt;Create&lt;/button&gt;\n    &lt;/form&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>By default, this does not work, and the reason for this is: the field id is used to control the <code>django-image-uploader-widget</code> and the field id is the same for each form. To solve this problem we have to change the field id attribute for each field, and this can be does changing the ModelForm:</p> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import Event\n\nclass EventEditForm(forms.ModelForm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if self.instance:\n            id = str(self.instance.pk)\n            self.fields['headshot'].widget.attrs['id'] = \"headshot_%s\" % id\n\n    class Meta:\n        model = Event\n        widgets = {\n            'headshot': ImageUploaderWidget(),\n        }\n        fields = [\n            'event_title',\n            'headshot'\n        ]\n</code></pre> <p>The original answer is disponible, also, in the github issue.</p>"}]}